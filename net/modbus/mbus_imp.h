#ifndef MODBUS_IMP_H
#define MODBUS_IMP_H
#pragma message	("@(#)mbus_imp.h")

/*
 * Драйвер сетевого протокола MODBUS
 */

#ifdef	__cplusplus
extern "C" {
#endif

#define CSU_T1          0 /* температура транзисторов/диодов */
#define CSU_T2          1
#define TASK_IC         2 /* задание ток заряда */
#define TASK_U          3 /* задание напряжение */
#define TASK_ID         4 /* задание ток разряда */
#define RD_ADC_MU       5 // канал измерения напряжения
#define RD_ADC_MI       6 // канал измерения тока
#define RD_ADC_DI       7 // канал измерения разрядного тока
#define RD_ADC_MUp      8 // канал измерения входного тока
#define CSU_ERR         9

#define REG_MAX         CSU_ERR /* максимальный номер регистра */
#define REG_NUM         (REG_MAX + 1) /* общее количество регистров */

#define MB_FUNC_DATA    6 /* количество сл. байт функции */
#define CRC_LEN         2 /* количество байт CRC */
#define LCR_LEN         1 /* количество байт LRC */
#define STOP_LEN        2 /* количество стоп байт ASCII */

#define MB_DATA_MAX    ((REG_NUM * sizeof(uint16_t)) + MB_FUNC_DATA)
/* размер буфера приема/передачи драйвера MODBUS RTU */
#define RTU_BUFF_LEN    (MB_DATA_MAX + CRC_LEN)
/* размер буфера приема/передачи драйвера MODBUS ASCII */
#define ASCII_BUFF_LEN  (((MB_DATA_MAX + LCR_LEN) * 2) + STOP_LEN)

#define MB_STOP_1       0x0d /* символ окончания кадра */
#define MB_STOP_2       0x0a /* символ готовности MASTER к приему ответа */
#define	MB_COMMON       0x00 /* широковещательный адрес MODBUS */

#define MB_ASCII_RX_MIN    7 /* минимальная длина кадра ASCII при приеме */

/* Функции (команды) протокола MODBUS */
/* Получить текущее значение одного или нескольких регистров хранения */
#define RD_HOLD_REG    03
/* Получить текущее значение одного или нескольких входных регистров */
#define RD_INP_REG     04
/* Установить логическую ячейку в состояние ON или OFF */
#define WR_COIL        05
/* Установить новые значения нескольких последовательных регистров */
#define WR_REG         16

/*
 * ПОЛЕ КОДА ФУНКЦИИ: В нормальном ответе, подчиненный повторяет код
 * функции содержащийся в поле кода функции запроса.
 * Во всех кодах функций старший значащий бит установлен в 0.
 * При возврате сообщения об ошибке подчиненный устанавливает этот бит в 1.
 */
#define ERROR_MASK  0x80

/* тип ошибок MODBUS, возвращаемых в квитанции */
typedef enum {
    /* Ошибок при обработке команды не обнаружено */
    NO_MB_ERROR          = 0,
    /* Принятый код функции не может быть обработан на подчиненном */
    ILLEGAL_FUNCTION     = 1,
    /* Адрес данных указанный в запросе не доступен данному подчиненному */
    ILLEGAL_DATA_ADDRESS = 2,
    /*
     * Величина содержащаяся в поле данных запроса является
     * не допустимой величиной для подчиненного
     */
    ILLEGAL_DATA_VALUE   = 3,
    /*
     * Невосстанавливаемая ошибка имела место пока подчиненный
     * пытался выполнить затребованное действие
     */
    SLAVE_DEVICE_FAILURE = 4,
    /*
     * Подчиненный принял запрос и обрабатывает его, но это требует
     * много времени. Этот ответ предохраняет главного от генерации
     * ошибки таймаута. Главный может выдать команду Poll Program Complete
     * для обнаружения завершения обработки команды.
     */
    ACKNOWLEDGE          = 5,
    /*
     * Подчиненный занят обработкой команды. Главный должен повторить
     * сообщение позже, когда подчиненный освободится.
     */
    SLAVE_DEVICE_BUSY    = 6,
    /*
     * Подчиненный не может выполнить программную функцию, принятую в запросе.
     * Этот код возвращается для неудачного программного запроса,
     * использующего функции с номерами 13 или 14. Главный должен запросить
     * диагностическую информацию или информацию обошибках с подчиненного.
     */
    NEGATIVE_ACKNOWLEDGE = 7,
    /*
     * Подчиненный пытается читать расширенную память, но обнаружил
     * ошибку паритета. Главный может повторить запрос, но обычно
     * в таких случаях требуется ремонт.
     */
    MEMORY_PARITY_ERROR  = 8
} MODBUS_ERROR;

/* подтип протокола MODBUS */
typedef enum {
    MODE_RTU   = 0,
    MODE_ASCII = 1
} BUS_MODE;

#ifdef __cplusplus
}
#endif

#endif /* MODBUS_IMP_H */
